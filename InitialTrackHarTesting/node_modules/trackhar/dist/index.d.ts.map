{"mappings":"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","sources":["src/src/common/adapter-util.ts","src/src/adapters/common/openrtb.ts","src/src/adapters/common/prebid-server.ts","src/src/adapters/adagio.ts","src/src/adapters/adcolony.ts","src/src/adapters/common/prebidjs.ts","src/src/adapters/adform.ts","src/src/adapters/adjust.ts","src/src/adapters/apple.ts","src/src/adapters/branch-io.ts","src/src/adapters/chartboost.ts","src/src/adapters/criteo.ts","src/src/adapters/equativ.ts","src/src/adapters/facebook.ts","src/src/adapters/google.ts","src/src/adapters/id5.ts","src/src/adapters/indexexchange.ts","src/src/adapters/infonline.ts","src/src/adapters/ironsource.ts","src/src/adapters/kidoz.ts","src/src/adapters/magnite.ts","src/src/adapters/media-net.ts","src/src/adapters/microsoft.ts","src/src/adapters/mopub.ts","src/src/adapters/onesignal.ts","src/src/adapters/openx.ts","src/src/adapters/outbrain.ts","src/src/adapters/pubmatic.ts","src/src/adapters/rayjump.ts","src/src/adapters/singular-net.ts","src/src/adapters/smartbear.ts","src/src/adapters/start-io.ts","src/src/adapters/taboola.ts","src/src/adapters/unity.ts","src/src/adapters/vungle.ts","src/src/adapters/yandex.ts","src/src/common/adapters.ts","src/src/common/protobuf.mjs","src/src/common/decode-functions.ts","src/src/common/request.ts","src/src/common/type-utils.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import { base64Regex } from 'base64-search';\nimport escapeStringRegexp from 'escape-string-regexp';\nimport type { Har } from 'har-format';\nimport { JSONPath } from 'jsonpath-plus';\nimport type { LiteralUnion } from 'type-fest';\nimport type translations from '../i18n/en.json';\nimport { allAdapters } from './common/adapters';\nimport { decodeFunction } from './common/decode-functions';\nimport type { Request } from './common/request';\nimport { unhar } from './common/request';\nimport type { ArrayOrSingle } from './common/type-utils';\n\n/** A JSONPath expression to be parsed by https://github.com/JSONPath-Plus/JSONPath. */\nexport type JsonPath = string;\n\n/**\n * A translation key for a tracker description, either for a {@link Tracker} or for an {@link Adapter}. At least the\n * English translation for the actual description needs to be provided in `i18n/en.json`.\n *\n * See the [README](https://github.com/tweaselORG/TrackHAR/blob/main/README.md#tracker-and-adapter-descriptions) for\n * additional details on the contents and markup.\n */\nexport type TrackerDescriptionTranslationKey = keyof (typeof translations)['tracker-descriptions'];\n\n/** Some value transmitted by a tracker. We don't have any type information about it. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type TrackingDataValue = any;\n\n/** A part of a request, to explain where some information was found. */\nexport type Context = 'header' | 'cookie' | 'path' | 'query' | 'body';\n\n/** A tracking company that we have adapters for. */\nexport type Tracker = {\n    /** A slug to identify the tracker. */\n    slug: string;\n    /** The legal name of the tracking company. */\n    name: string;\n    /**\n     * The translation key for an introductory description that gives context on the tracking company, if that makes\n     * sense and the description applies equally to all adapters assigned to the company.\n     */\n    description?: TrackerDescriptionTranslationKey;\n    /**\n     * The numeric ID of the tracker in the [Exodus tracker\n     * database](https://reports.exodus-privacy.eu.org/en/trackers/) (if available).\n     */\n    exodusId?: number;\n    /**\n     * The slug of the tracking company in the [Datenanfragen.de company database](https://www.datarequests.org/company)\n     * (if available).\n     */\n    datenanfragenSlug?: string;\n};\n/**\n * A type of tracking data that we can detect in a request.\n *\n * These are our standardized names for the data that we can detect. They are not necessarily the same as the names used\n * by the tracker.\n *\n * @remarks\n * - `state` here means \"subnational political entity\"\n * - Locales should not be listed under `country`\n * - We distinguish the following types of IDs (that are personal data under the GDPR):\n *\n *   - An `advertisingId` is a unique identifier assigned to a device by the operating system that is the same across\n *       apps/websites. In particular, this includes the Google Advertising ID (GAID) and Apple's Identifier for\n *       Advertisers (IDFA). These can typically be reset by the user.\n *   - A `developerScopedId` is a unique identifier assigned to a device by the operating system that is specific to a\n *       certain app developer. Apps from different developers will see different `developerScopedId`s. In particular,\n *       this includes Apple's Identifier for Vendor (IDFV), Google's App set ID (ASID), and the `ANDROID_ID`.\n *   - A `sessionId` identifies a single (time-limited) session and is specific to a certain website/app and device.\n *   - An `installationId` identifies an installation of an app on a device. It specific to that app and device, and reset\n *       when the app is un- and reinstalled.\n *   - A `deviceId` identifies a device across apps/websites.\n *   - A `userId` identifies a user across apps/websites and devices.\n *   - We use the `otherIdentifiers` data property to denote UUIDs and other identifiers where we don't know how they are\n *       actually used. This should only be used sparingly and where, despite not knowing the precise function, it is\n *       obvious (from context or otherwise) that this ID is personal data.\n */\nexport type Property = keyof (typeof translations)['properties'];\n/** A variable on the global state used in the decoding process of a request. This doesn't allow nested property access. */\nexport type Variable = LiteralUnion<Context | 'res', string>;\n/**\n * A JSONPath expression that can be used to access a variable or nested property on the global state in the decoding\n * process of a request.\n */\nexport type Path = LiteralUnion<Variable, JsonPath>;\n/**\n * An identifer for a variable or nested property on the global state in the decoding process of a request. This\n * **doesn't** have support for more complex JSONPath expressions.\n */\nexport type Identifier =\n    | Variable\n    | `${Exclude<Variable, 'res'>}.${string}`\n    | `res.${Context}`\n    | `res.${Context}.${string}`;\n/**\n * A step in the process of decoding a tracking request. This is essentially a function call with some input and output,\n * and potentially additional options.\n *\n * The `input` is a JSONPath expression which is evaluated against the global decoding state (initialized with the data\n * from each {@link Context} of the request, and a `res` object, where the result of the decoding is to be stored,\n * separated by {@link Context}; new variables can be created by decoding steps).\\\n * Alternatively, if a `mapInput` is specified instead, the function will be mapped over the array at the given path,\n * returning a result array.\n *\n * The `output` is an identifier of where to store the return value of the function call in the same global decoding\n * state. Note that this doesn't support the full range of JSONPath expressions, but only nested property access through\n * `.`.\n *\n * The following `function`s are available:\n *\n * - `parseQueryString`: Parses a query string encoded value into an object.\n * - `parseJson`: Parses a JSON encoded string into an object.\n * - `decodeBase64`: Decodes a base64-encoded string.\n * - `decodeUrl`: Decodes a URL-encoded string.\n * - `decodeProtobuf`: Decodes a Protobuf blob. This doesn't use a schema, as such property names are not available in the\n *   result.\n * - `decodeJwt`: Decodes the payload of a JSON Web Token (JWT) string into an object.\n * - `ensureArray`: Ensures that the given value is an array. If it is not, it is wrapped in an array.\n * - `gunzip`: Unzips a gzip-compressed blob.\n * - `split`: Splits a string into an array using the given separator.\n * - `getProperty`: Gets a property from an object. The property name is given in the `options.path` option. This is\n *   useful for either copying a nested property to a variable, or to extract a nested property from an array when used\n *   with a `mapInput`.\n */\nexport type DecodingStep = (\n    | {\n          function:\n              | 'parseQueryString'\n              | 'parseJson'\n              | 'decodeBase64'\n              | 'decodeUrl'\n              | 'decodeProtobuf'\n              | 'decodeJwt'\n              | 'ensureArray'\n              | 'gunzip';\n      }\n    | { function: 'split'; options: { separator: string } }\n    | { function: 'getProperty'; options: { path: JsonPath } }\n) &\n    (({ input: Path } | { mapInput: Path }) & { output: Identifier });\n\n/** A description of where a certain piece of tracking data can be found in the decoded request. */\nexport type DataPath = {\n    /** The part of the original request that the data can be found in. */\n    context: Context;\n    /** A JSONPath expression describing where in the decoded request object the data can be found. */\n    path: JsonPath;\n    /** An optional filter that stops a discovered value from being considered an instance of the respective property. */\n    notIf?: string | RegExp;\n    /** An optional filter that causes only matching values to be considered instances of the respective property. */\n    onlyIf?: string | RegExp;\n    /**\n     * An explanation of how we concluded that this is information is actually the type of data we labelled it as. This\n     * can either be a standardized description, or a URL to a more in-depth research report.\n     */\n    reasoning:\n        | 'obvious property name'\n        | 'obvious observed values'\n        | 'observed values match known device parameters'\n        | `https://${string}`\n        | `http://${string}`\n        | `${string}.md`;\n};\n/**\n * An adapter that contains instructions on how to extract the tracking data included in a request to certain endpoints.\n *\n * Handling for one endpoint might be split across multiple adapters if the endpoint accepts different request formats.\n *\n * The first adapter that matches a request will be used to decode it.\n */\nexport type Adapter = {\n    /** A slug to identify the adapter. These only need to be unique per tracker, not globally. */\n    slug: string;\n    /** A human-readable name for the adapter. This should be as close as possible to the official name for the endpoint. */\n    name: string;\n    /** The translation key for a description that gives context on the endpoint, if that makes sense. */\n    description?: TrackerDescriptionTranslationKey;\n    /** The tracking company behind these endpoints. */\n    tracker: Tracker;\n\n    /**\n     * The endpoints that this adapter can handle.\n     *\n     * Each entry can either be a string (which will have to be equal to the full endpoint URL in the request) or a\n     * regular expression that is matched against the endpoint URL.\n     *\n     * The endpoint URL in this context is the full URL, including protocol, host, and path, but excluding the query\n     * string. It should not have a trailing slash.\n     */\n    endpointUrls: (string | RegExp)[];\n    /**\n     * An optional function to further filter which requests can be handled by this adapter.\n     *\n     * This is useful if there are multiple adapters for one endpoint that handle different request formats.\n     */\n    match?: (r: Request) => boolean | undefined;\n\n    /** An array of the steps (in order) used to decode the request into an object format. */\n    decodingSteps: DecodingStep[];\n    /** A description of how to extract the transmitted tracking data from the decoded object. */\n    containedDataPaths: Partial<Record<Property, ArrayOrSingle<DataPath>>>;\n};\n\n/**\n * Decode a request into an object representation using the given decoding steps.\n *\n * @remarks\n * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.\n *\n * @param r The request to decode in our internal request format.\n * @param decodingSteps The decoding steps to use (from the adapter).\n *\n * @returns An object representation of the request.\n */\nexport const decodeRequest = (r: Request, decodingSteps: DecodingStep[]) => {\n    const [path, query] = r.path.split('?');\n\n    const reduceHeadersOrCookies = (headersOrCookies: typeof r.headers | typeof r.cookies) =>\n        headersOrCookies?.reduce<Record<string, string>>((acc, cur) => ({ ...acc, [cur.name]: cur.value }), {});\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const vars: Record<Variable, any> & { res: Partial<Record<Context, any>> } = {\n        header: reduceHeadersOrCookies(r.headers),\n        cookie: reduceHeadersOrCookies(r.cookies),\n        path,\n        query,\n        body: r.content,\n        res: {},\n    };\n\n    const get = (id: Path) => JSONPath({ path: id, json: vars, wrap: false });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const set = (id: Identifier, value: any) => {\n        const path = id.split('.');\n        const last = path.pop();\n        if (!last) throw new Error('Invalid path');\n\n        let current = vars;\n        for (const p of path) {\n            let next = Array.isArray(current) ? current[+p] : current[p];\n            if (!next) current[p] = {};\n            next = Array.isArray(current) ? current[+p] : current[p];\n            current = next;\n        }\n        if (Array.isArray(current)) current[+last] = value;\n        else current[last] = value;\n    };\n\n    for (const step of decodingSteps) {\n        if ('mapInput' in step) {\n            const mapInput = get(step.mapInput) || [];\n            if (!Array.isArray(mapInput)) throw new Error('mapInput must be an array.');\n            const result = mapInput\n                .filter((i) => i !== undefined && i !== null)\n                .map((i) => decodeFunction(step.function, i, (step as { options: unknown }).options));\n            if (result) set(step.output, result);\n            continue;\n        }\n\n        const input = get(step.input);\n        if (!input) continue;\n\n        const result = decodeFunction(step.function, input, (step as { options: unknown }).options);\n        if (result) set(step.output, result);\n    }\n\n    return vars.res;\n};\n\n/**\n * Find the adapter that can handle a certain request.\n *\n * @remarks\n * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.\n *\n * @param r The request to find an adapter for.\n *\n * @returns The adapter that can handle the request, or `undefined` if none could be found.\n */\nexport const adapterForRequest = (r: Request) =>\n    allAdapters.find(\n        (a) =>\n            a.endpointUrls.some((url) =>\n                url instanceof RegExp\n                    ? url.test(r.endpointUrl) || url.test(r.endpointUrl.replace(/\\/$/, ''))\n                    : url === r.endpointUrl || url === r.endpointUrl.replace(/\\/$/, '')\n            ) && (a.match ? a.match(r) : true)\n    );\n/**\n * Parse a single request in our internal request representation and extract tracking data as an annotated result from\n * it.\n *\n * @remarks\n * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.\n *\n * @param request The request to process in our internal request format.\n * @param options An optional object that can configure the following options:\n *\n *   - `indicatorValues`: An object that specifies known honey data values for certain properties. If no adapter could match\n *       the request but indicator values are provided, this function will fall back to indicator matching and try to\n *       find the indicator values in the request headers, path or body. See {@link IndicatorValues}.\n */\nexport const processRequest = (\n    request: Request,\n    options?: { indicatorValues?: IndicatorValues }\n): AnnotatedResult | undefined => {\n    const adapter = adapterForRequest(request);\n    if (!adapter) {\n        if (!options?.indicatorValues) return undefined;\n\n        // If no adapter could match the request but the user provided indicator values, we fall back to indicator\n        // matching.\n        const indicators = Object.entries(options.indicatorValues)\n            .map(([property, valueOrValues]) =>\n                (Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues])\n                    .filter((value): value is string => value !== undefined)\n                    .map((value) => ({\n                        property: property as keyof IndicatorValues,\n                        indicatorValue: value,\n                    }))\n            )\n            .flat();\n\n        const indicatorMatches = indicators\n            .map(({ property, indicatorValue }) =>\n                (['header', 'path', 'body'] as const).map((context) =>\n                    (['plain text', 'base64', 'URL-encoded'] as const).map((encoding) => {\n                        const haystack =\n                            context === 'body'\n                                ? request.content || ''\n                                : context === 'path'\n                                ? request.path\n                                : (request.headers || []).map(({ name, value }) => `${name}: ${value}`).join('\\n');\n                        const encodedIndicatorValue =\n                            encoding === 'plain text'\n                                ? indicatorValue\n                                : encoding === 'base64'\n                                ? base64Regex(indicatorValue)\n                                : encodeURIComponent(indicatorValue);\n                        // We don't want to match multiple times if the encoding is equivalent to plain text.\n                        if (encoding !== 'plain text' && encodedIndicatorValue === indicatorValue) return undefined;\n\n                        const caseInsensitive = ['plain text', 'URL-encoded'].includes(encoding) ? 'i' : '';\n                        const matches = haystack.matchAll(\n                            new RegExp(escapeStringRegexp(encodedIndicatorValue), `g${caseInsensitive}`)\n                        );\n\n                        return [...matches].map((m) => ({\n                            adapter: 'indicators',\n                            property,\n                            context,\n                            path: `$[${m.index}]`,\n                            reasoning: `indicator matching (${encoding})` as const,\n                            value: m[0],\n                        }));\n                    })\n                )\n            )\n            .flat(3)\n            .filter((r): r is Exclude<typeof r, undefined> => r !== undefined);\n        if (indicatorMatches.length > 0) return indicatorMatches;\n        return undefined;\n    }\n\n    // If an adapter matched, we only return its results.\n    const decodedRequest = decodeRequest(request, adapter.decodingSteps);\n\n    const flattenedPaths = Object.entries(adapter.containedDataPaths)\n        .map(([property, paths]) => (Array.isArray(paths) ? paths : [paths]).map((p) => [property, p] as const))\n        .flat();\n    /**\n     * Transform a value transmitted by a tracker, which can be any type, into a string, choosing the most\n     * \"natural-feeling\" representation to make it filterable.\n     *\n     * For example, objects and arrays will be returned as JSON strings, whereas strings will be returned as-is (and\n     * thus notably without enclosing quotes as `JSON.stringify` would add).\n     */\n    const stringify = (v: unknown) =>\n        typeof v === 'bigint' || typeof v === 'string' || typeof v === 'symbol' || typeof v === 'function'\n            ? v.toString()\n            : JSON.stringify(v);\n    return flattenedPaths\n        .map(([property, path]) =>\n            (JSONPath<TrackingDataValue[]>({ path: path.path, json: decodedRequest[path.context], wrap: true }) ?? [])\n                .map((v) => ({\n                    adapter: `${adapter.tracker.slug}/${adapter.slug}`,\n                    property: property as Property,\n                    ...path,\n                    value: v,\n                }))\n                .filter((v) => v.value !== undefined && v.value !== null && v.value.trim?.() !== '')\n                .filter(\n                    (v) =>\n                        ![\n                            'unknown',\n                            'null',\n                            'undefined',\n                            'none',\n                            'n/a',\n                            '00000000-0000-0000-0000-000000000000',\n                            '\"\"',\n                            \"''\",\n                            '[object Object]',\n                        ].includes(stringify(v.value).toLowerCase().trim()) &&\n                        !['NaN'].includes(stringify(v.value).trim())\n                )\n                .filter(\n                    (v) =>\n                        !v.onlyIf ||\n                        (typeof v.onlyIf === 'string'\n                            ? v.onlyIf === stringify(v.value)\n                            : v.onlyIf.test(stringify(v.value)))\n                )\n                .filter(\n                    (v) =>\n                        !v.notIf ||\n                        (typeof v.notIf === 'string'\n                            ? v.notIf !== stringify(v.value)\n                            : !v.notIf.test(stringify(v.value)))\n                )\n        )\n        .flat();\n};\n\n/**\n * Extended version of the {@link Result} type that includes additional metadata about the detected tracking. Each entry\n * in the array is one instance of a tracking data value that was found in a request, with the following properties:\n *\n * - `adapter`: The adapter that detected the tracking data (`<tracker slug>/<adapter slug>`) or `indicators` if the entry\n *   was detected through indicator matching.\n * - `property`: The type of tracking data that was detected.\n * - `value`: The actual value of the tracking data that was transmitted.\n * - `context`: The part of the request in which the tracking data was found (e.g. `body`, `path`).\n * - `path`: A JSONPath expression indicating where this match was found. Note that while we try to keep this path as\n *   close as possible to the format used by the tracker, it refers to the decoded request, after our processing steps.\n *   This is unavoidable as the trackers don't transmit in a standardized format.\n *\n *   If indicator matching was used to detect this entry, the path will point to the first character of the match in the\n *   respective part of the request.\n * - `reasoning`: An explanation of how we concluded that this is information is actually the type of data we labelled it\n *   as. This can either be a standardized description, or a URL to a more in-depth research report.\n *\n *   If indicator matching was used to detect this entry, the reasoning will be `indicator matching` followed by the\n *   encoding that was used to match the indicator value in parentheses.\n */\nexport type AnnotatedResult = ({\n    adapter: string;\n    property: LiteralUnion<Property, string>;\n    value: TrackingDataValue;\n    reasoning:\n        | DataPath['reasoning']\n        | 'indicator matching (plain text)'\n        | 'indicator matching (base64)'\n        | 'indicator matching (URL-encoded)';\n} & Omit<DataPath, 'reasoning'>)[];\n/**\n * A mapping from properties (standardized names for certain types of tracking data) to the actual instances of values\n * of that property found in a request.\n *\n * If indicator matching is enabled, it is not possible to distinguish between instances detected through adapter and\n * indicator matching.\n */\nexport type Result = Partial<Record<LiteralUnion<Property, string>, TrackingDataValue[]>>;\n\n/**\n * A mapping from properties (standardized names for certain types of tracking data) to indicator values (known honey\n * data strings that appear in the request if the property is present). Indicator values can be provided as arrays or\n * single strings. They are automatically matched against their encoded versions (e.g. base64 and URL-encoded). Where\n * possible, they are matched case-insensitively.\n *\n * @example\n *\n * ```ts\n * {\n *     \"localIp\": [\"10.0.0.2\", \"fd31:4159::a2a1\"],\n *     \"advertisingId\": \"6a1c1487-a0af-4223-b142-a0f4621d0311\"\n * }\n * ```\n *\n * This example means that if the string `10.0.0.2` or `fd31:4159::a2a1` is found in the request, it indicates that the\n * local IP is being transmitted. Similarly, if the string `6a1c1487-a0af-4223-b142-a0f4621d0311` is found in the\n * request, it indicates that the advertising ID is being transmitted.\n */\nexport type IndicatorValues = Partial<Record<LiteralUnion<Property, string>, ArrayOrSingle<string>>>;\n\n/**\n * Parse the requests in a HAR traffic dump and extract tracking data.\n *\n * This always tries to parse requests with the tracker-specific adapters first. If none of them can handle a request,\n * and `options.indicatorValues` is provided, it will fall back to indicator matching.\n *\n * @param har A traffic dump in HAR format.\n * @param options An optional object that can configure the following options:\n *\n *   - `valuesOnly`: By default, the result contains not just the values but also various metadata (like the adapter that\n *       processed the request). If you only need the values, you can set this option to `true` to get a simpler\n *       result.\n *   - `indicatorValues`: An object that specifies known honey data values for certain properties. If no adapter could match\n *       the request but indicator values are provided, this function will fall back to indicator matching and try to\n *       find the indicator values in the request headers, path or body. See {@link IndicatorValues}.\n *\n * @returns An array of results, corresponding to each request in the HAR file. If a request could not be processed\n *   (i.e. if no adapter was found that could handle it and indicator matching, if enabled, didn't produce any results),\n *   the corresponding entry in the array will be `undefined`.\n */\nexport const process = async <ValuesOnly extends boolean = false>(\n    har: Har,\n    options?: { valuesOnly?: ValuesOnly; indicatorValues?: IndicatorValues }\n): Promise<ValuesOnly extends true ? (Result | undefined)[] : (AnnotatedResult | undefined)[]> => {\n    const res = await Promise.all(unhar(har).map((r) => processRequest(r, options)));\n\n    const ret = options?.valuesOnly\n        ? res.map((req) =>\n              req?.reduce<Result>(\n                  (acc, cur) => ({\n                      ...acc,\n                      [cur.property]: acc[cur.property]?.concat(cur.value) || [cur.value],\n                  }),\n                  {}\n              )\n          )\n        : res;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return ret as any;\n};\n\n/**\n * An array of all available adapters.\n *\n * @remarks\n * This is not needed for the main purposes of this library, but can be useful for more advanced use cases. We use it to\n * generate the information in [`tracker-wiki`](https://github.com/tweaselORG/tracker-wiki).\n */\n// Somehow export ... from './common/adapters' breaks the typedef, so we use this\nexport const adapters = allAdapters;\n\nexport { unhar };\nexport { ArrayOrSingle, Request };\n"],"names":[],"version":3,"file":"index.d.ts.map"}