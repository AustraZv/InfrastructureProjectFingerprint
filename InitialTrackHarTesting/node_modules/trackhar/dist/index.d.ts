import { Har } from "har-format";
import { LiteralUnion } from "type-fest";
import translations from "i18n/en";
/** Our internal representation of an HTTP request. */
export type Request = {
    /** The time when the request was sent. */
    startTime: Date;
    /** The HTTP method used. */
    method: string;
    /** The host name of the request. */
    host: string;
    /** The full path of the request, including the query string. */
    path: string;
    /** The full URL, but without the query string. This is useful for matching in the adapters. */
    endpointUrl: string;
    /** The request body, if any. */
    content?: string;
    /** The port of the request. */
    port: string;
    /** The scheme of the request. */
    scheme: 'http' | 'https';
    /** The HTTP version of the request. */
    httpVersion: string;
    /** The headers included in the request. */
    headers?: {
        name: string;
        value: string;
    }[];
    /** The cookies set through request. */
    cookies?: {
        name: string;
        value: string;
    }[];
};
/**
 * Parse a traffic dump in HAR format into our internal request representation.
 *
 * @param har The HAR traffic dump.
 */
export const unhar: (har: Har) => Request[];
/** Either a single instance or an array of `T`. */
export type ArrayOrSingle<T> = T | T[];
/** A JSONPath expression to be parsed by https://github.com/JSONPath-Plus/JSONPath. */
export type JsonPath = string;
/**
 * A translation key for a tracker description, either for a {@link Tracker} or for an {@link Adapter}. At least the
 * English translation for the actual description needs to be provided in `i18n/en.json`.
 *
 * See the [README](https://github.com/tweaselORG/TrackHAR/blob/main/README.md#tracker-and-adapter-descriptions) for
 * additional details on the contents and markup.
 */
export type TrackerDescriptionTranslationKey = keyof (typeof translations)['tracker-descriptions'];
/** Some value transmitted by a tracker. We don't have any type information about it. */
export type TrackingDataValue = any;
/** A part of a request, to explain where some information was found. */
export type Context = 'header' | 'cookie' | 'path' | 'query' | 'body';
/** A tracking company that we have adapters for. */
export type Tracker = {
    /** A slug to identify the tracker. */
    slug: string;
    /** The legal name of the tracking company. */
    name: string;
    /**
     * The translation key for an introductory description that gives context on the tracking company, if that makes
     * sense and the description applies equally to all adapters assigned to the company.
     */
    description?: TrackerDescriptionTranslationKey;
    /**
     * The numeric ID of the tracker in the [Exodus tracker
     * database](https://reports.exodus-privacy.eu.org/en/trackers/) (if available).
     */
    exodusId?: number;
    /**
     * The slug of the tracking company in the [Datenanfragen.de company database](https://www.datarequests.org/company)
     * (if available).
     */
    datenanfragenSlug?: string;
};
/**
 * A type of tracking data that we can detect in a request.
 *
 * These are our standardized names for the data that we can detect. They are not necessarily the same as the names used
 * by the tracker.
 *
 * @remarks
 * - `state` here means "subnational political entity"
 * - Locales should not be listed under `country`
 * - We distinguish the following types of IDs (that are personal data under the GDPR):
 *
 *   - An `advertisingId` is a unique identifier assigned to a device by the operating system that is the same across
 *       apps/websites. In particular, this includes the Google Advertising ID (GAID) and Apple's Identifier for
 *       Advertisers (IDFA). These can typically be reset by the user.
 *   - A `developerScopedId` is a unique identifier assigned to a device by the operating system that is specific to a
 *       certain app developer. Apps from different developers will see different `developerScopedId`s. In particular,
 *       this includes Apple's Identifier for Vendor (IDFV), Google's App set ID (ASID), and the `ANDROID_ID`.
 *   - A `sessionId` identifies a single (time-limited) session and is specific to a certain website/app and device.
 *   - An `installationId` identifies an installation of an app on a device. It specific to that app and device, and reset
 *       when the app is un- and reinstalled.
 *   - A `deviceId` identifies a device across apps/websites.
 *   - A `userId` identifies a user across apps/websites and devices.
 *   - We use the `otherIdentifiers` data property to denote UUIDs and other identifiers where we don't know how they are
 *       actually used. This should only be used sparingly and where, despite not knowing the precise function, it is
 *       obvious (from context or otherwise) that this ID is personal data.
 */
export type Property = keyof (typeof translations)['properties'];
/** A variable on the global state used in the decoding process of a request. This doesn't allow nested property access. */
export type Variable = LiteralUnion<Context | 'res', string>;
/**
 * A JSONPath expression that can be used to access a variable or nested property on the global state in the decoding
 * process of a request.
 */
export type Path = LiteralUnion<Variable, JsonPath>;
/**
 * An identifer for a variable or nested property on the global state in the decoding process of a request. This
 * **doesn't** have support for more complex JSONPath expressions.
 */
export type Identifier = Variable | `${Exclude<Variable, 'res'>}.${string}` | `res.${Context}` | `res.${Context}.${string}`;
/**
 * A step in the process of decoding a tracking request. This is essentially a function call with some input and output,
 * and potentially additional options.
 *
 * The `input` is a JSONPath expression which is evaluated against the global decoding state (initialized with the data
 * from each {@link Context} of the request, and a `res` object, where the result of the decoding is to be stored,
 * separated by {@link Context}; new variables can be created by decoding steps).\
 * Alternatively, if a `mapInput` is specified instead, the function will be mapped over the array at the given path,
 * returning a result array.
 *
 * The `output` is an identifier of where to store the return value of the function call in the same global decoding
 * state. Note that this doesn't support the full range of JSONPath expressions, but only nested property access through
 * `.`.
 *
 * The following `function`s are available:
 *
 * - `parseQueryString`: Parses a query string encoded value into an object.
 * - `parseJson`: Parses a JSON encoded string into an object.
 * - `decodeBase64`: Decodes a base64-encoded string.
 * - `decodeUrl`: Decodes a URL-encoded string.
 * - `decodeProtobuf`: Decodes a Protobuf blob. This doesn't use a schema, as such property names are not available in the
 *   result.
 * - `decodeJwt`: Decodes the payload of a JSON Web Token (JWT) string into an object.
 * - `ensureArray`: Ensures that the given value is an array. If it is not, it is wrapped in an array.
 * - `gunzip`: Unzips a gzip-compressed blob.
 * - `split`: Splits a string into an array using the given separator.
 * - `getProperty`: Gets a property from an object. The property name is given in the `options.path` option. This is
 *   useful for either copying a nested property to a variable, or to extract a nested property from an array when used
 *   with a `mapInput`.
 */
export type DecodingStep = ({
    function: 'parseQueryString' | 'parseJson' | 'decodeBase64' | 'decodeUrl' | 'decodeProtobuf' | 'decodeJwt' | 'ensureArray' | 'gunzip';
} | {
    function: 'split';
    options: {
        separator: string;
    };
} | {
    function: 'getProperty';
    options: {
        path: JsonPath;
    };
}) & (({
    input: Path;
} | {
    mapInput: Path;
}) & {
    output: Identifier;
});
/** A description of where a certain piece of tracking data can be found in the decoded request. */
export type DataPath = {
    /** The part of the original request that the data can be found in. */
    context: Context;
    /** A JSONPath expression describing where in the decoded request object the data can be found. */
    path: JsonPath;
    /** An optional filter that stops a discovered value from being considered an instance of the respective property. */
    notIf?: string | RegExp;
    /** An optional filter that causes only matching values to be considered instances of the respective property. */
    onlyIf?: string | RegExp;
    /**
     * An explanation of how we concluded that this is information is actually the type of data we labelled it as. This
     * can either be a standardized description, or a URL to a more in-depth research report.
     */
    reasoning: 'obvious property name' | 'obvious observed values' | 'observed values match known device parameters' | `https://${string}` | `http://${string}` | `${string}.md`;
};
/**
 * An adapter that contains instructions on how to extract the tracking data included in a request to certain endpoints.
 *
 * Handling for one endpoint might be split across multiple adapters if the endpoint accepts different request formats.
 *
 * The first adapter that matches a request will be used to decode it.
 */
export type Adapter = {
    /** A slug to identify the adapter. These only need to be unique per tracker, not globally. */
    slug: string;
    /** A human-readable name for the adapter. This should be as close as possible to the official name for the endpoint. */
    name: string;
    /** The translation key for a description that gives context on the endpoint, if that makes sense. */
    description?: TrackerDescriptionTranslationKey;
    /** The tracking company behind these endpoints. */
    tracker: Tracker;
    /**
     * The endpoints that this adapter can handle.
     *
     * Each entry can either be a string (which will have to be equal to the full endpoint URL in the request) or a
     * regular expression that is matched against the endpoint URL.
     *
     * The endpoint URL in this context is the full URL, including protocol, host, and path, but excluding the query
     * string. It should not have a trailing slash.
     */
    endpointUrls: (string | RegExp)[];
    /**
     * An optional function to further filter which requests can be handled by this adapter.
     *
     * This is useful if there are multiple adapters for one endpoint that handle different request formats.
     */
    match?: (r: Request) => boolean | undefined;
    /** An array of the steps (in order) used to decode the request into an object format. */
    decodingSteps: DecodingStep[];
    /** A description of how to extract the transmitted tracking data from the decoded object. */
    containedDataPaths: Partial<Record<Property, ArrayOrSingle<DataPath>>>;
};
/**
 * Decode a request into an object representation using the given decoding steps.
 *
 * @remarks
 * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.
 *
 * @param r The request to decode in our internal request format.
 * @param decodingSteps The decoding steps to use (from the adapter).
 *
 * @returns An object representation of the request.
 */
export const decodeRequest: (r: Request, decodingSteps: DecodingStep[]) => any;
/**
 * Find the adapter that can handle a certain request.
 *
 * @remarks
 * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.
 *
 * @param r The request to find an adapter for.
 *
 * @returns The adapter that can handle the request, or `undefined` if none could be found.
 */
export const adapterForRequest: (r: Request) => Adapter | undefined;
/**
 * Parse a single request in our internal request representation and extract tracking data as an annotated result from
 * it.
 *
 * @remarks
 * This is not needed for the main purposes of this library, but can be useful for more advanced use cases.
 *
 * @param request The request to process in our internal request format.
 * @param options An optional object that can configure the following options:
 *
 *   - `indicatorValues`: An object that specifies known honey data values for certain properties. If no adapter could match
 *       the request but indicator values are provided, this function will fall back to indicator matching and try to
 *       find the indicator values in the request headers, path or body. See {@link IndicatorValues}.
 */
export const processRequest: (request: Request, options?: {
    indicatorValues?: IndicatorValues;
}) => AnnotatedResult | undefined;
/**
 * Extended version of the {@link Result} type that includes additional metadata about the detected tracking. Each entry
 * in the array is one instance of a tracking data value that was found in a request, with the following properties:
 *
 * - `adapter`: The adapter that detected the tracking data (`<tracker slug>/<adapter slug>`) or `indicators` if the entry
 *   was detected through indicator matching.
 * - `property`: The type of tracking data that was detected.
 * - `value`: The actual value of the tracking data that was transmitted.
 * - `context`: The part of the request in which the tracking data was found (e.g. `body`, `path`).
 * - `path`: A JSONPath expression indicating where this match was found. Note that while we try to keep this path as
 *   close as possible to the format used by the tracker, it refers to the decoded request, after our processing steps.
 *   This is unavoidable as the trackers don't transmit in a standardized format.
 *
 *   If indicator matching was used to detect this entry, the path will point to the first character of the match in the
 *   respective part of the request.
 * - `reasoning`: An explanation of how we concluded that this is information is actually the type of data we labelled it
 *   as. This can either be a standardized description, or a URL to a more in-depth research report.
 *
 *   If indicator matching was used to detect this entry, the reasoning will be `indicator matching` followed by the
 *   encoding that was used to match the indicator value in parentheses.
 */
export type AnnotatedResult = ({
    adapter: string;
    property: LiteralUnion<Property, string>;
    value: TrackingDataValue;
    reasoning: DataPath['reasoning'] | 'indicator matching (plain text)' | 'indicator matching (base64)' | 'indicator matching (URL-encoded)';
} & Omit<DataPath, 'reasoning'>)[];
/**
 * A mapping from properties (standardized names for certain types of tracking data) to the actual instances of values
 * of that property found in a request.
 *
 * If indicator matching is enabled, it is not possible to distinguish between instances detected through adapter and
 * indicator matching.
 */
export type Result = Partial<Record<LiteralUnion<Property, string>, TrackingDataValue[]>>;
/**
 * A mapping from properties (standardized names for certain types of tracking data) to indicator values (known honey
 * data strings that appear in the request if the property is present). Indicator values can be provided as arrays or
 * single strings. They are automatically matched against their encoded versions (e.g. base64 and URL-encoded). Where
 * possible, they are matched case-insensitively.
 *
 * @example
 *
 * ```ts
 * {
 *     "localIp": ["10.0.0.2", "fd31:4159::a2a1"],
 *     "advertisingId": "6a1c1487-a0af-4223-b142-a0f4621d0311"
 * }
 * ```
 *
 * This example means that if the string `10.0.0.2` or `fd31:4159::a2a1` is found in the request, it indicates that the
 * local IP is being transmitted. Similarly, if the string `6a1c1487-a0af-4223-b142-a0f4621d0311` is found in the
 * request, it indicates that the advertising ID is being transmitted.
 */
export type IndicatorValues = Partial<Record<LiteralUnion<Property, string>, ArrayOrSingle<string>>>;
/**
 * Parse the requests in a HAR traffic dump and extract tracking data.
 *
 * This always tries to parse requests with the tracker-specific adapters first. If none of them can handle a request,
 * and `options.indicatorValues` is provided, it will fall back to indicator matching.
 *
 * @param har A traffic dump in HAR format.
 * @param options An optional object that can configure the following options:
 *
 *   - `valuesOnly`: By default, the result contains not just the values but also various metadata (like the adapter that
 *       processed the request). If you only need the values, you can set this option to `true` to get a simpler
 *       result.
 *   - `indicatorValues`: An object that specifies known honey data values for certain properties. If no adapter could match
 *       the request but indicator values are provided, this function will fall back to indicator matching and try to
 *       find the indicator values in the request headers, path or body. See {@link IndicatorValues}.
 *
 * @returns An array of results, corresponding to each request in the HAR file. If a request could not be processed
 *   (i.e. if no adapter was found that could handle it and indicator matching, if enabled, didn't produce any results),
 *   the corresponding entry in the array will be `undefined`.
 */
export const process: <ValuesOnly extends boolean = false>(har: Har, options?: {
    valuesOnly?: ValuesOnly | undefined;
    indicatorValues?: Partial<Record<LiteralUnion<"accelerometerX" | "accelerometerY" | "accelerometerZ" | "advertisingId" | "appId" | "appName" | "appVersion" | "architecture" | "batteryLevel" | "browserId" | "browserWindowHeight" | "browserWindowWidth" | "campaignCreative" | "campaignCreativePosition" | "campaignMedium" | "campaignName" | "campaignSource" | "campaignTerm" | "carrier" | "consentState" | "country" | "currency" | "developerScopedId" | "deviceId" | "deviceName" | "diskFree" | "diskTotal" | "diskUsed" | "errorInformation" | "hashedAdvertisingId" | "installationId" | "installTime" | "interactedElement" | "isAutomated" | "isCharging" | "isConversion" | "isDntEnabled" | "isEmulator" | "isFirstLaunch" | "isInDarkMode" | "isInForeground" | "isJsEnabled" | "isMobileDevice" | "isRoaming" | "isRooted" | "isUserActive" | "isUserInactive" | "language" | "lastActivityTime" | "latitude" | "localIp" | "longitude" | "macAddress" | "manufacturer" | "model" | "networkConnectionType" | "orientation" | "osName" | "osVersion" | "otherIdentifiers" | "pageHeight" | "pageWidth" | "propertyId" | "publicIp" | "pushNotificationToken" | "ramFree" | "ramTotal" | "ramUsed" | "referer" | "revenue" | "rotationX" | "rotationY" | "rotationZ" | "screenColorDepth" | "screenHeight" | "screenWidth" | "scrollPositionX" | "scrollPositionY" | "segment" | "sessionCount" | "sessionDuration" | "sessionId" | "signalStrengthCellular" | "signalStrengthWifi" | "startTime" | "state" | "timeSpent" | "timezone" | "trackerSdkVersion" | "uptime" | "userAction" | "userActionSource" | "userActiveTime" | "userAgent" | "userGender" | "userId" | "userInterests" | "viewedPage" | "viewedPageCategory" | "viewedPageKeywords" | "viewedPageLanguage" | "volume" | "websiteName" | "websiteUrl", string>, ArrayOrSingle<string>>> | undefined;
} | undefined) => Promise<ValuesOnly extends true ? (Partial<Record<LiteralUnion<"accelerometerX" | "accelerometerY" | "accelerometerZ" | "advertisingId" | "appId" | "appName" | "appVersion" | "architecture" | "batteryLevel" | "browserId" | "browserWindowHeight" | "browserWindowWidth" | "campaignCreative" | "campaignCreativePosition" | "campaignMedium" | "campaignName" | "campaignSource" | "campaignTerm" | "carrier" | "consentState" | "country" | "currency" | "developerScopedId" | "deviceId" | "deviceName" | "diskFree" | "diskTotal" | "diskUsed" | "errorInformation" | "hashedAdvertisingId" | "installationId" | "installTime" | "interactedElement" | "isAutomated" | "isCharging" | "isConversion" | "isDntEnabled" | "isEmulator" | "isFirstLaunch" | "isInDarkMode" | "isInForeground" | "isJsEnabled" | "isMobileDevice" | "isRoaming" | "isRooted" | "isUserActive" | "isUserInactive" | "language" | "lastActivityTime" | "latitude" | "localIp" | "longitude" | "macAddress" | "manufacturer" | "model" | "networkConnectionType" | "orientation" | "osName" | "osVersion" | "otherIdentifiers" | "pageHeight" | "pageWidth" | "propertyId" | "publicIp" | "pushNotificationToken" | "ramFree" | "ramTotal" | "ramUsed" | "referer" | "revenue" | "rotationX" | "rotationY" | "rotationZ" | "screenColorDepth" | "screenHeight" | "screenWidth" | "scrollPositionX" | "scrollPositionY" | "segment" | "sessionCount" | "sessionDuration" | "sessionId" | "signalStrengthCellular" | "signalStrengthWifi" | "startTime" | "state" | "timeSpent" | "timezone" | "trackerSdkVersion" | "uptime" | "userAction" | "userActionSource" | "userActiveTime" | "userAgent" | "userGender" | "userId" | "userInterests" | "viewedPage" | "viewedPageCategory" | "viewedPageKeywords" | "viewedPageLanguage" | "volume" | "websiteName" | "websiteUrl", string>, any[]>> | undefined)[] : (AnnotatedResult | undefined)[]>;
/**
 * An array of all available adapters.
 *
 * @remarks
 * This is not needed for the main purposes of this library, but can be useful for more advanced use cases. We use it to
 * generate the information in [`tracker-wiki`](https://github.com/tweaselORG/tracker-wiki).
 */
export const adapters: Adapter[];

//# sourceMappingURL=index.d.ts.map
